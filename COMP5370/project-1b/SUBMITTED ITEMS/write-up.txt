test-case-a: Marshalling Unicode character
  why-can-be-abused: When your program fails to encode or error out when attempting to marshal a Unicode character, it can lead to serious problems such as a Unicode character being passed to a program that does not support the used encoding. Without being percent encoded first, this could cause many problems, and possibly affect parts outside the scope of the serializer and deserializer. Unicode can be used in some instances of attacks such as Unicode phishing. These attacks can lead to worse cases such as getting into the system, and being able to read, write, or modify inputs.

  root-cause: The root cause of this problem is when the serializer fails to percent encode or error out when passed Unicode text as the value in an entry of the dictionary. A simple check for Unicode characters in the input would stop all chances of Unicode being passed through the marshal or unmarshal.

  root-cause-rationale: If the value of the dictionary passed to be marshalled is a Unicode character and the serializer does not encode it or stop the program, then this can cause many problems. The root cause for this will be the serializer not first checking that the value does not contain any Unicode.
=========================================================================================================

test-case-b: Recursion limit DoS
why-can-be-abused: When the deserializer is passed a very nested marshalled nosj value to unmarshal, then it can lead to a very long stack of recursion calls. This can cause the deserializer to be forced to be stuck on one value to unmarshal for a long amount of time, possibly preventing others from being able to access the program depending on how the server is configured. This could lead to multiple calls of the same string being unmarshalled to cause the program to constantly only be working on one string, and can easily eat the server's resources. This could be the beginning of a DoS attack making the server unable to function until it is manually reset.

root-cause: The root cause of this problem will be if the recursion limit has been changed in the python environment that is running the deserializer. If the recursion limit is set too high, then this will allow the long string to go through and possibly use too many resources and block others from accessing the program.

root-cause-rationale: Our justification for this root-cause is that the recursion limit in Python is by default set at 1000, which means that the stack for the program can only allow up to 1000 nested recursion calls. If this number is increased, that allows for the client to pass in more nested dictionaries as strings to be unmarshalled. Because there is also no length of string check on the deserializer, then this leads to problems where the client can arbitrarily use as many resources as they want on the server. This can lead to problems for other users as the server will not be able to handle their requests as well.
===========================================================================================================

  Test-case-c: marshaling null character in key of dictionary
  why-can-be-abused: marshaling a null character (such as {'\00':...} ) from serialization should throw an error, however, using the null character in the key can sometimes let it through since a lot of programs only check for these characters in the value. And most of the time, if the null character can pass through the marshal, if you try to then unmarshal the result an error is thrown. Null characters need to always be dealt with in every scenario since they can be used for different attacks when left alone. These can be anything from modifying directories, or any other path traversal attack.

  root-cause: This is caused by not being sure to deal with any and all instances of null characters. In some cases we did not check for the null in the key of the dictionary, and we are told it is not a valid input. Furthermore, even if Serialization catches this null byte and deals with it by simply letting it pass, the unmarshalling in deserialization will certainly crash since it must convert back from string to type dictionary. This creates a problem since an attacker may continuously pass a null character and continuously crash the program.

  root-cause-rationale: This effects our program mostly because the null_byte attacks are growing every day in how easy it is for a DoS attack to occur by simply passing a null character. This shows why the author must go through these programs and make sure there are checks in each space of any type to ensure there are no null bits. It is easy to see why these attacks are growing more common since going through to check every space in an input for this program is not too bad, however, you can clearly see that with a larger program this could add a lot of time and remove a lot of efficiency. Therefore, the author must find balance in checking as many spaces as possible to clear, without checking too many places making the program slow/inefficient.
===========================================================================================================

test-case-d: Malformed map to be deserialized
  why-can-be-abused: This can be abused by passing in invalid maps that should error out. By using this vulnerability, malicious attackers can possibly use invalid inputs that pass through the validation to add strings that should not be allowed. This strange behavior could possibly allow for different attacks. By not properly validating the input, the deserializer can possibly be compromised and the attacker can have free range to pass in inputs that would normally be invalid if they use incorrect map formats.

  root-cause: The root cause of this problem is that the input string for a map is not always properly validated. If there is an extra bracket, it can be treated as part of a string instead of being errored out for not following the specification for input.

  root-cause-rationale: The rationale for this root-cause is that the deserializer will treat the malformed string as it would any other string instead of verifying that it does not contain any unallowed characters. If you pass in a bracket, the deserializer should raise an exception, however if it does not check to make sure that all characters are valid before adding the string, then this can lead to a map that should be invalid being added to one value, as shown in our example test case.
===========================================================================================================

test-case-e: Duplicate key
  why-can-be-abused: This can be abused because it allows duplicate keys to be passed into the deserializer. When this happens, it could potentially lead to values being overwritten by the second instance of the same key. This should error out to prevent data from being overwritten without the client knowing that it was happening. If this does not, it can possibly lead to unexpected behavior where the client expects one value but receives the second one. This is not good as this could lead to values and keys not being in the same place anymore and means the output could contain the wrong message in its value. 

  root-cause: The root cause of this problem is not checking that the dictionary does not already have the key that you are currently unmarshalling. If it does, it should error out to let the client know that there is a duplicate key, and will lead to problems or at the very least one value will be overwritten. This causes a big problem when assembling the dictionaries back together since some of the keys could be overwritten/missing. 

  root-cause-rationale: The rationale for this root-cause is that if the deserializer does not check that each key is unique before inserting it into the dictionary, then the first instance of a duplicate key will be overwritten. This can be considered proper behavior, but it also happens without the user knowing about it, and should instead error out and allow the user to make a change to their string to prevent unknowingly overwriting their data.
